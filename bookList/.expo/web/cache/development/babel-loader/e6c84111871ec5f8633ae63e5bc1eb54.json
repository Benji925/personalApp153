{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nvar dataUriPattern = /^data:/;\n\nvar ImageUriCache = function () {\n  function ImageUriCache() {\n    _classCallCheck(this, ImageUriCache);\n  }\n\n  _createClass(ImageUriCache, null, [{\n    key: \"has\",\n    value: function has(uri) {\n      var entries = ImageUriCache._entries;\n      var isDataUri = dataUriPattern.test(uri);\n      return isDataUri || Boolean(entries[uri]);\n    }\n  }, {\n    key: \"add\",\n    value: function add(uri) {\n      var entries = ImageUriCache._entries;\n      var lastUsedTimestamp = Date.now();\n\n      if (entries[uri]) {\n        entries[uri].lastUsedTimestamp = lastUsedTimestamp;\n        entries[uri].refCount += 1;\n      } else {\n        entries[uri] = {\n          lastUsedTimestamp: lastUsedTimestamp,\n          refCount: 1\n        };\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(uri) {\n      var entries = ImageUriCache._entries;\n\n      if (entries[uri]) {\n        entries[uri].refCount -= 1;\n      }\n\n      ImageUriCache._cleanUpIfNeeded();\n    }\n  }, {\n    key: \"_cleanUpIfNeeded\",\n    value: function _cleanUpIfNeeded() {\n      var entries = ImageUriCache._entries;\n      var imageUris = Object.keys(entries);\n\n      if (imageUris.length + 1 > ImageUriCache._maximumEntries) {\n        var leastRecentlyUsedKey;\n        var leastRecentlyUsedEntry;\n        imageUris.forEach(function (uri) {\n          var entry = entries[uri];\n\n          if ((!leastRecentlyUsedEntry || entry.lastUsedTimestamp < leastRecentlyUsedEntry.lastUsedTimestamp) && entry.refCount === 0) {\n            leastRecentlyUsedKey = uri;\n            leastRecentlyUsedEntry = entry;\n          }\n        });\n\n        if (leastRecentlyUsedKey) {\n          delete entries[leastRecentlyUsedKey];\n        }\n      }\n    }\n  }]);\n\n  return ImageUriCache;\n}();\n\nImageUriCache._maximumEntries = 256;\nImageUriCache._entries = {};\nexport { ImageUriCache as default };","map":{"version":3,"sources":["/Users/bengreene/Desktop/SummerWork/personalApp153/bookList/node_modules/react-native-web/src/exports/Image/ImageUriCache.js"],"names":["dataUriPattern","ImageUriCache","uri","entries","_entries","isDataUri","test","Boolean","lastUsedTimestamp","Date","now","refCount","_cleanUpIfNeeded","imageUris","Object","keys","length","_maximumEntries","leastRecentlyUsedKey","leastRecentlyUsedEntry","forEach","entry"],"mappings":";;AASA,IAAMA,cAAc,GAAG,QAAvB;;IAEqBC,a;;;;;;;wBAIRC,G,EAAa;AACtB,UAAMC,OAAO,GAAGF,aAAa,CAACG,QAA9B;AACA,UAAMC,SAAS,GAAGL,cAAc,CAACM,IAAf,CAAoBJ,GAApB,CAAlB;AACA,aAAOG,SAAS,IAAIE,OAAO,CAACJ,OAAO,CAACD,GAAD,CAAR,CAA3B;AACD;;;wBAEUA,G,EAAa;AACtB,UAAMC,OAAO,GAAGF,aAAa,CAACG,QAA9B;AACA,UAAMI,iBAAiB,GAAGC,IAAI,CAACC,GAAL,EAA1B;;AACA,UAAIP,OAAO,CAACD,GAAD,CAAX,EAAkB;AAChBC,QAAAA,OAAO,CAACD,GAAD,CAAP,CAAaM,iBAAb,GAAiCA,iBAAjC;AACAL,QAAAA,OAAO,CAACD,GAAD,CAAP,CAAaS,QAAb,IAAyB,CAAzB;AACD,OAHD,MAGO;AACLR,QAAAA,OAAO,CAACD,GAAD,CAAP,GAAe;AACbM,UAAAA,iBAAiB,EAAjBA,iBADa;AAEbG,UAAAA,QAAQ,EAAE;AAFG,SAAf;AAID;AACF;;;2BAEaT,G,EAAa;AACzB,UAAMC,OAAO,GAAGF,aAAa,CAACG,QAA9B;;AACA,UAAID,OAAO,CAACD,GAAD,CAAX,EAAkB;AAChBC,QAAAA,OAAO,CAACD,GAAD,CAAP,CAAaS,QAAb,IAAyB,CAAzB;AACD;;AAEDV,MAAAA,aAAa,CAACW,gBAAd;AACD;;;uCAEyB;AACxB,UAAMT,OAAO,GAAGF,aAAa,CAACG,QAA9B;AACA,UAAMS,SAAS,GAAGC,MAAM,CAACC,IAAP,CAAYZ,OAAZ,CAAlB;;AAEA,UAAIU,SAAS,CAACG,MAAV,GAAmB,CAAnB,GAAuBf,aAAa,CAACgB,eAAzC,EAA0D;AACxD,YAAIC,oBAAJ;AACA,YAAIC,sBAAJ;AAEAN,QAAAA,SAAS,CAACO,OAAV,CAAkB,UAAAlB,GAAG,EAAI;AACvB,cAAMmB,KAAK,GAAGlB,OAAO,CAACD,GAAD,CAArB;;AACA,cACE,CAAC,CAACiB,sBAAD,IACCE,KAAK,CAACb,iBAAN,GAA0BW,sBAAsB,CAACX,iBADnD,KAEAa,KAAK,CAACV,QAAN,KAAmB,CAHrB,EAIE;AACAO,YAAAA,oBAAoB,GAAGhB,GAAvB;AACAiB,YAAAA,sBAAsB,GAAGE,KAAzB;AACD;AACF,SAVD;;AAYA,YAAIH,oBAAJ,EAA0B;AACxB,iBAAOf,OAAO,CAACe,oBAAD,CAAd;AACD;AACF;AACF;;;;;;AAzDkBjB,a,CACZgB,e,GAA0B,G;AADdhB,a,CAEZG,Q,GAAW,E;SAFCH,a","sourcesContent":["/**\n * Copyright (c) Nicolas Gallagher.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nconst dataUriPattern = /^data:/;\n\nexport default class ImageUriCache {\n  static _maximumEntries: number = 256;\n  static _entries = {};\n\n  static has(uri: string) {\n    const entries = ImageUriCache._entries;\n    const isDataUri = dataUriPattern.test(uri);\n    return isDataUri || Boolean(entries[uri]);\n  }\n\n  static add(uri: string) {\n    const entries = ImageUriCache._entries;\n    const lastUsedTimestamp = Date.now();\n    if (entries[uri]) {\n      entries[uri].lastUsedTimestamp = lastUsedTimestamp;\n      entries[uri].refCount += 1;\n    } else {\n      entries[uri] = {\n        lastUsedTimestamp,\n        refCount: 1\n      };\n    }\n  }\n\n  static remove(uri: string) {\n    const entries = ImageUriCache._entries;\n    if (entries[uri]) {\n      entries[uri].refCount -= 1;\n    }\n    // Free up entries when the cache is \"full\"\n    ImageUriCache._cleanUpIfNeeded();\n  }\n\n  static _cleanUpIfNeeded() {\n    const entries = ImageUriCache._entries;\n    const imageUris = Object.keys(entries);\n\n    if (imageUris.length + 1 > ImageUriCache._maximumEntries) {\n      let leastRecentlyUsedKey;\n      let leastRecentlyUsedEntry;\n\n      imageUris.forEach(uri => {\n        const entry = entries[uri];\n        if (\n          (!leastRecentlyUsedEntry ||\n            entry.lastUsedTimestamp < leastRecentlyUsedEntry.lastUsedTimestamp) &&\n          entry.refCount === 0\n        ) {\n          leastRecentlyUsedKey = uri;\n          leastRecentlyUsedEntry = entry;\n        }\n      });\n\n      if (leastRecentlyUsedKey) {\n        delete entries[leastRecentlyUsedKey];\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}